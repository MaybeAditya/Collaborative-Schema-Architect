import React, { useCallback, useEffect, useRef, useState } from 'react';
import ReactFlow, {
    useNodesState,
    useEdgesState,
    Background,
    Controls,
    MiniMap,
    addEdge // Helper to manage connections
} from 'reactflow';
import 'reactflow/dist/style.css';
import * as Y from 'yjs';
import { HocuspocusProvider } from '@hocuspocus/provider';
import TableNode from './TableNode';

const nodeTypes = { table: TableNode };

const SchemaDesigner = () => {
    const [nodes, setNodes, onNodesChange] = useNodesState([]);
    const [edges, setEdges, onEdgesChange] = useEdgesState([]);
    const [sqlCode, setSqlCode] = useState('');

    const ydoc = useRef(new Y.Doc()).current;
    const providerRef = useRef(null);
    const yNodesMap = useRef(null);
    const yEdgesMap = useRef(null); // NEW: Store connections

    useEffect(() => {
        const provider = new HocuspocusProvider({
            url: 'ws://127.0.0.1:1234',
            name: 'schema-room-v3', // Bump version to clear old "random" data
            document: ydoc,
        });
        providerRef.current = provider;

        yNodesMap.current = ydoc.getMap('project-nodes');
        yEdgesMap.current = ydoc.getMap('project-edges');

        // 1. SYNC NODES
        yNodesMap.current.observe(() => {
            const newNodes = Array.from(yNodesMap.current.values()).map(node => ({
                ...node,
                data: {
                    ...node.data,
                    // Attach interactive functions to the data object
                    onChangeLabel: (val) => updateNodeLabel(node.id, val),
                    onAddColumn: () => addColumn(node.id)
                }
            }));
            setNodes(newNodes);
            generateSQL(newNodes, Array.from(yEdgesMap.current.values()));
        });

        // 2. SYNC EDGES (The Strings!)
        yEdgesMap.current.observe(() => {
            const newEdges = Array.from(yEdgesMap.current.values());
            setEdges(newEdges);
            // Regenerate SQL when connections change
            generateSQL(Array.from(yNodesMap.current.values()), newEdges);
        });

        return () => provider.destroy();
    }, []);

    // --- ACTIONS ---

    // Handle Connecting Two Tables
    const onConnect = useCallback((params) => {
        // params contains { source: "node-1", target: "node-2" }
        const edgeId = `edge-${params.source}-${params.target}`;
        const newEdge = { ...params, id: edgeId, type: 'smoothstep', animated: true, style: { stroke: '#007acc' } };

        // Save to Yjs (Everyone sees the line)
        yEdgesMap.current.set(edgeId, newEdge);
    }, []);

    // Handle Renaming
    const updateNodeLabel = (id, newLabel) => {
        const node = yNodesMap.current.get(id);
        yNodesMap.current.set(id, {
            ...node,
            data: { ...node.data, label: newLabel }
        });
    };

    // Handle Adding a Column (Simple implementation)
    const addColumn = (id) => {
        const node = yNodesMap.current.get(id);
        const newCol = { name: 'new_col', type: 'VARCHAR' };
        yNodesMap.current.set(id, {
            ...node,
            data: { ...node.data, columns: [...node.data.columns, newCol] }
        });
    };

    const addTable = () => {
        const id = `table-${Date.now()}`;
        const newNode = {
            id,
            type: 'table',
            position: { x: Math.random() * 400 + 50, y: Math.random() * 400 + 50 },
            data: {
                label: 'Untitled_Table',
                columns: [{ name: 'id', type: 'INT PK' }] // Initial columns
            },
        };
        yNodesMap.current.set(id, newNode);
    };

    // --- THE COMPILER (Now with Relationships) ---
    const generateSQL = (nodesList, edgesList) => {
        if (nodesList.length === 0) return;

        let sql = "-- ðŸš€ Auto-generated by InterviewSync \n\n";

        nodesList.forEach(node => {
            const tableName = node.data.label.replace(/\s/g, '_');
            sql += `CREATE TABLE ${tableName} (\n`;

            // 1. Render Columns
            node.data.columns.forEach(col => {
                sql += `  ${col.name} ${col.type},\n`;
            });

            // 2. Render Foreign Keys (Based on "Strings")
            // Find edges where THIS node is the Target
            const incomingEdges = edgesList.filter(e => e.target === node.id);

            incomingEdges.forEach(edge => {
                // Find the source table name
                const sourceNode = nodesList.find(n => n.id === edge.source);
                if (sourceNode) {
                    const sourceName = sourceNode.data.label;
                    sql += `  ${sourceName.toLowerCase()}_id INT,\n`;
                    sql += `  FOREIGN KEY (${sourceName.toLowerCase()}_id) REFERENCES ${sourceName}(id),\n`;
                }
            });

            sql = sql.slice(0, -2) + "\n"; // Remove trailing comma
            sql += `);\n\n`;
        });

        setSqlCode(sql);
    };

    return (
        <div style={{ width: '100vw', height: '100vh', display: 'flex', background: '#0d0d0d' }}>
            <div style={{ flex: 3, position: 'relative', borderRight: '1px solid #333' }}>
                <button onClick={addTable} style={{ position: 'absolute', top: 20, left: 20, zIndex: 10, padding: '10px 20px', background: '#007acc', color: 'white', border: 'none', borderRadius: '4px', cursor: 'pointer', fontWeight: 'bold' }}>
                    + Add Table
                </button>

                <ReactFlow
                    nodes={nodes}
                    edges={edges}
                    nodeTypes={nodeTypes}
                    onNodesChange={onNodesChange}
                    onEdgesChange={onEdgesChange}
                    onConnect={onConnect} // This enables the "String" dragging
                    fitView
                >
                    <Background color="#222" gap={20} />
                    <Controls />
                    <MiniMap style={{ background: '#111' }} nodeColor="#007acc" />
                </ReactFlow>
            </div>

            <div style={{ flex: 1, background: '#111', padding: '20px', overflowY: 'auto', fontFamily: 'monospace' }}>
                <div style={{ color: '#555', marginBottom: '10px', fontSize: '12px', fontWeight: 'bold' }}>GENERATED SQL</div>
                <pre style={{ color: '#ce9178', fontSize: '13px', whiteSpace: 'pre-wrap' }}>{sqlCode}</pre>
            </div>
        </div>
    );
};

export default SchemaDesigner;